        -:    0:Source:slist.h
        -:    0:Graph:libnl_getlink.gcno
        -:    0:Data:libnl_getlink.gcda
        -:    0:Runs:1
        -:    1:#ifndef _SLIST_H_
        -:    2:#define _SLIST_H_
        -:    3:
        -:    4:/*
        -:    5: * Singly-linked list
        -:    6: */
        -:    7:
        -:    8:/* Macros for branch prediction */
        -:    9:#ifndef likely
        -:   10:#define likely(x) __builtin_expect(!!(x), 1)
        -:   11:#endif
        -:   12:
        -:   13:#ifndef unlikely
        -:   14:#define unlikely(x) __builtin_expect(!!(x), 0)
        -:   15:#endif
        -:   16:
        -:   17:#ifndef NULL
        -:   18:#define NULL 0
        -:   19:#endif
        -:   20:
        -:   21:/* Offset of member MEMBER in a struct of type TYPE. */
        -:   22:#define offsetof_(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)
        -:   23:
        -:   24:#define container_of_(ptr, type, member) ({            \
        -:   25:    const typeof(((type *)0)->member) *__mptr = (ptr);    \
        -:   26:    (type *)((char *)__mptr - offsetof_(type, member)); })
        -:   27:
        -:   28:typedef struct slist_node {
        -:   29:  struct slist_node *next;
        -:   30:} slist_node_t;
        -:   31:
        -:   32:typedef struct slist_head {
        -:   33:  slist_node_t *head; /* head element */
        -:   34:  slist_node_t *tail; /* tail element */
        -:   35:} slist_head_t;
        -:   36:
        -:   37:/* Инициализация головы списка */
        -:   38:static inline void INIT_SLIST_HEAD(struct slist_head *list) {
        -:   39:  list->head = NULL;
        -:   40:  list->tail = NULL;
        -:   41:}
        -:   42:
        -:   43:/* Проверка, пуст ли список */
function slist_empty called 22 returned 100% blocks executed 75%
       22:   44:static inline int slist_empty(const struct slist_head *list) {
       22:   45:  if (unlikely(list == NULL)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   46:    return 1; /* Если список не существует, считаем его пустым */
        -:   47:  }
       22:   48:  return (list->head == NULL) ? 1 : 0;
        -:   49:}
        -:   50:
        -:   51:/* Добавление в начало списка */
        -:   52:static inline void slist_add(struct slist_node *new, struct slist_head *list) {
        -:   53:  if (unlikely((new == NULL) || (list == NULL))) {
        -:   54:    return;
        -:   55:  }
        -:   56:
        -:   57:  new->next = list->head;
        -:   58:  list->head = new;
        -:   59:
        -:   60:  /* Если список был пустой, обновляем tail */
        -:   61:  if (unlikely(list->tail == NULL)) {
        -:   62:    list->tail = new;
        -:   63:  }
        -:   64:}
        -:   65:
        -:   66:/* Добавление в конец списка */
function slist_add_tail called 11 returned 100% blocks executed 90%
       11:   67:static inline void slist_add_tail(struct slist_node *new, struct slist_head *list) {
       11:   68:  if (unlikely((new == NULL) || (list == NULL))) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   69:    return;
        -:   70:  }
        -:   71:
       11:   72:  new->next = NULL;
        -:   73:
       11:   74:  if (likely(slist_empty(list) == 0)) {
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
       10:   75:    if (likely(list->tail != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:   76:      list->tail->next = new; /* Присоединяем к последнему */
        -:   77:    }
        -:   78:  } else {
        1:   79:    list->head = new; /* Если список пустой */
        -:   80:  }
        -:   81:
       11:   82:  list->tail = new; /* Обновляем указатель на последний элемент */
        -:   83:}
        -:   84:
        -:   85:/* Удаление первого элемента списка */
function slist_del_head called 11 returned 100% blocks executed 88%
       11:   86:static inline void slist_del_head(struct slist_head *list) {
       11:   87:  if (unlikely((list == NULL) || (slist_empty(list) != 0))) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:   88:    return;
        -:   89:  }
        -:   90:
       11:   91:  struct slist_node *first = list->head;
       11:   92:  if (likely(first != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       11:   93:    list->head = first->next;
        -:   94:
        -:   95:    /* Если это был последний элемент, обнуляем tail */
       11:   96:    if (unlikely(list->head == NULL)) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
        1:   97:      list->tail = NULL;
        -:   98:    }
        -:   99:  }
        -:  100:}
        -:  101:
        -:  102:/* Удаление указанного элемента, следующего за prev (или головы, если prev == NULL) */
function slist_del_next called 0 returned 0% blocks executed 0%
    #####:  103:static inline void slist_del_next(struct slist_node *prev, struct slist_head *list) {
    #####:  104:  if (unlikely(list == NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  105:    return;
        -:  106:  }
        -:  107:
    #####:  108:  if (unlikely(prev == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  109:    /* Удаляем первый элемент списка */
    #####:  110:    slist_del_head(list);
call    0 never executed
    #####:  111:    return;
        -:  112:  }
        -:  113:
        -:  114:  /* Проверка на наличие следующего элемента */
    #####:  115:  if (unlikely(prev->next == NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  116:    return;
        -:  117:  }
        -:  118:
    #####:  119:  struct slist_node *to_del = prev->next;
    #####:  120:  prev->next = to_del->next;
        -:  121:
        -:  122:  /* Если удаляемый был последним, обновляем tail */
    #####:  123:  if (unlikely(to_del == list->tail)) {
branch  0 never executed
branch  1 never executed
    #####:  124:    list->tail = prev;
        -:  125:  }
        -:  126:}
        -:  127:
        -:  128:/* Удаление конкретного элемента из списка */
function slist_del_node called 11 returned 100% blocks executed 47%
       11:  129:static inline int slist_del_node(struct slist_node *node, struct slist_head *list) {
      11*:  130:  if (unlikely(list == NULL || node == NULL || list->head == NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####:  131:    return -1;
        -:  132:  }
        -:  133:
        -:  134:  /* Если это головной элемент */
       11:  135:  if (list->head == node) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       11:  136:    slist_del_head(list);
call    0 returned 100%
       11:  137:    return 0;
        -:  138:  }
        -:  139:
        -:  140:  /* Ищем предыдущий элемент */
    #####:  141:  struct slist_node *prev = list->head;
    #####:  142:  while (prev && prev->next != node) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  143:    prev = prev->next;
        -:  144:  }
        -:  145:
    #####:  146:  if (prev) {
branch  0 never executed
branch  1 never executed
        -:  147:    /* Нашли предыдущий, удаляем текущий */
    #####:  148:    slist_del_next(prev, list);
call    0 never executed
    #####:  149:    return 0;
        -:  150:  }
        -:  151:
    #####:  152:  return -1; /* Элемент не найден */
        -:  153:}
        -:  154:
        -:  155:/* Получаем контейнер узла списка */
        -:  156:#define slist_entry(ptr, type, member) \
        -:  157:  container_of_(ptr, type, member)
        -:  158:
        -:  159:/* Получаем первый элемент списка */
        -:  160:#define slist_head_entry(list, type, member) \
        -:  161:  (likely((list)->head != NULL) ? slist_entry((list)->head, type, member) : NULL)
        -:  162:
        -:  163:/* Получаем следующий элемент списка */
        -:  164:#define slist_next_entry(pos, member) \
        -:  165:  (likely((pos) != NULL && (pos)->member.next != NULL) ? slist_entry((pos)->member.next, typeof(*(pos)), member) : NULL)
        -:  166:
        -:  167:/* Итерация по всем элементам списка */
        -:  168:#define slist_for_each(pos, list)                            \
        -:  169:  for (pos = (likely((list) != NULL) ? (list)->head : NULL); \
        -:  170:       likely(pos != NULL);                                  \
        -:  171:       pos = pos->next)
        -:  172:
        -:  173:/* Итерация по всем элементам списка с получением структуры-владельца */
        -:  174:#define slist_for_each_entry(pos, list, member)                                                       \
        -:  175:  for (pos = (likely((list)->head != NULL) ? slist_entry((list)->head, typeof(*pos), member) : NULL); \
        -:  176:       likely(pos != NULL);                                                                           \
        -:  177:       pos = (likely((pos)->member.next != NULL) ? slist_entry((pos)->member.next, typeof(*pos), member) : NULL))
        -:  178:
        -:  179:/* Безопасная итерация с отслеживанием следующего элемента (можно удалять текущий элемент) */
        -:  180:#define slist_for_each_safe(pos, next, list)                 \
        -:  181:  for (pos = (likely((list) != NULL) ? (list)->head : NULL), \
        -:  182:      next = (likely(pos != NULL) ? (pos)->next : NULL);     \
        -:  183:       likely(pos != NULL);                                  \
        -:  184:       pos = next,                                           \
        -:  185:      next = (likely(next != NULL) ? next->next : NULL))
        -:  186:
        -:  187:/* Безопасная итерация для удаления элементов */
        -:  188:#define slist_for_each_entry_safe(pos, temp, list, member)                                                                       \
        -:  189:  for (pos = (likely((list)->head != NULL) ? slist_entry((list)->head, typeof(*pos), member) : NULL),                            \
        -:  190:      temp = (likely(pos != NULL && (pos)->member.next != NULL) ? slist_entry((pos)->member.next, typeof(*pos), member) : NULL); \
        -:  191:       likely(pos != NULL);                                                                                                      \
        -:  192:       pos = temp,                                                                                                               \
        -:  193:      temp = (likely(temp != NULL && (temp)->member.next != NULL) ? slist_entry((temp)->member.next, typeof(*temp), member) : NULL))
        -:  194:
        -:  195:#endif /* _SLIST_H_ */
